# nextJS-1

## 설치

- npx create-next-app@latest --typescript

## 주요특징

- SSR, SEO부터 TypeScript까지 제공하는 아주 강력한 React 프레임워크

## 사용법

- a 태그 => Link 컴포넌트로 수정하여 사용 (Link로 a 태그를 감싼다.)

```js
import Link from 'next/link';

const Nav = () => {
  return (
    <nav>
      <Link href="/">
        <a>home</a>
      </Link>
      <Link href="/about">
        <a>about</a>
      </Link>
    </nav>
  );
};

export default Nav;
```

- import Head from 'next/head';
- head를 변경 할 수 있다.

```js
<Head>
  <title>Create Next App</title>
  <meta name="description" content="Generated by create next app" />
  <link rel="icon" href="/favicon.ico" />
</Head>
```

- import Image from 'next/image';
- 이미지사용시 사용. public/ 에 있는 이미지를 사용

```js
<Image src="/vercel.svg" alt="Vercel Logo" width={72} height={16} />
```

### CSS 사용하는 2가지 방법

- {타이틀}.module.css 를 사용하며 사용을 원하는 컴포넌트에 import 하여 사용한다.
- module.css 이외에 다른 css는 import 할 수 없다.(전역 CSS 사용시 \_app.js 에서 사용)
- styles jsx 사용 컴포넌트 jsx 내에 <style jsx></style> 태그 안에 CSS를 정의한다.(스코프가 컴포넌트에만 국한된다.)

```js
const Nav = () => {
  return (
    <>
      <nav>
        <Link href="/">
          <a>home</a>
        </Link>
        <Link href="/about">
          <a>about</a>
        </Link>
      </nav>
      <style jsx>{`
        nav {
          color: red;
        }
      `}</style>
    </>
  );
};
```

### \_app.js (전역 CSS, 공통 컴포넌트 사용)

- \_app.js: index.js 를 읽기전에 \_app.js 를 먼저 읽는다.
- \_app.js 안에 공통적인 사항들을 저장 할 수 있다.(일종의 템플릿으로 사용)
- 초기 세팅시 자동으로 \_app.js 파일이 생성된다.

```js
function MyApp({ Component, pageProps }: AppProps) {
  return (
    <>
      <Nav />
      <Component {...pageProps} />
    </>
  );
}
```

- 일반적으로 Layout.js 컴포넌트를 생성하여 레이아웃을 만들어준다.

```js
import Nav from './Nav';

const Layout = ({ children }) => {
  return (
    <>
      <Nav />
      <div>{children}</div>
    </>
  );
};

export default Layout;
```

```js
import Layout from '../components/Layout';

function MyApp({ Component, pageProps }: AppProps) {
  return (
    <>
      <Layout>
        <Component {...pageProps} />
      </Layout>
    </>
  );
}

export default MyApp;
```

- 페이지마다 Head를 지정해주기위해 Seo.tsx 컴포넌트를 생성하여 거기에 지정한다.

```js
import Head from 'next/head';

interface SeoProps {
  title: string;
}

const Seo = ({ title }: SeoProps) => {
  return (
    <Head>
      <title>{title} | NextJS</title>
    </Head>
  );
};

export default Seo;
```

```js
import Seo from '../components/Seo';

const Home = () => {
  return (
    <>
      <Seo title="Home" />
      <h1>Home</h1>
    </>
  );
};

export default Home;
```

- .env 사용시 NEXT*PUBLIC* 를 접미사로 붙여서 사용한다.

### next.config.js

- Node.js 모듈
- Next.js 서버 및 빌드 단계에서 사용되며 브라우저 빌드에는 포함되지 않음

#### 속성

- Redirects: Redirect을 사용하면 들어오는 request 경로를 다른 destination 경로로 Redirect
- 프론트 단에서 URL 변경됨!
- :path\* 도 사용가능

```js
const nextConfig = {
  reactStrictMode: true,
  async redirects() {
    return [
      {
        source: '/api/movies/:mode/:params',
        destination: `https://api.themoviedb.org/3/movie/:mode?api_key=${
          process.env.NEXT_PUBLIC_API_KEY
        }${encodeURIComponent('&')}:params`,
        permanent: false,
      },
    ];
  },
};
```

- Rewrites를 사용하면 들어오는 request 경로를 다른 destination 경로에 매핑
- URL 프록시 역할을 하고 destination 경로를 mask하여 사용자가 사이트에서 위치를 변경하지 않은 것처럼 보이게함 (URL 변경안됨!)

```js
const nextConfig = {
  reactStrictMode: true,
  async rewrites() {
    return [
      {
        source: '/api/movies',
        destination: `https://api.themoviedb.org/3/movie/popular?api_key=${process.env.NEXT_PUBLIC_API_KEY}&language=en-US&page=1`,
      },
    ];
  },
};
```

### getServerSideProps(): 서버사이드에서 props 를 넣어서 사용

```js
export default function Home({ results }: HomePorps) {
  return (
    <>
      <Seo title="Home" />
      <h1>Home</h1>
      {results.map((movie) => (
        <div key={movie.id}>{movie.title}</div>
      ))}
    </>
  );
}

export async function getServerSideProps() {
  const { results } = await (
    await fetch(`http://localhost:3000/api/movies/popular/language=ko-KR`)
  ).json();

  return {
    props: {
      results,
    },
  };
}
```

### 페이지

- pages/ 에 있는 파일명에 따라 라우트가 설정된다.(index는 '/'로 생성 / 예외!)
- 페이지가 아닌 것들은 components/ 폴더를 생성하여 넣는다.
- 뎁스가 있는 url은 폴더로 생성한다.

```js
// pages/movies/index.js
/movies
// pages/movies/all.js
/movies/all
// pages/movies/[id].js
/movies/:id
```

- url 변수 사용(:id)
- 컴포넌트안에 router.query 값에서 가져와서 사용
- [...id].js 파일명을 사용하면 12/12/12/12/ 같은 모든 url 을 다 가져올 수 있다.

```js
import { useRouter } from 'next/router';

export default function Detail() {
  const router = useRouter();
  console.log('@', router.query.id);
  return <>Movie Detail</>;
}
```

- useRouter().push(url, as, options)
- <Link href=""> 와 동일한 메소드, 유저가 무언가를 했을때, 사용한다.
- 외부 URL에 대해서는 window.location을 사용하는 것이 더 적합
- <Link>, useRouter().push, 둘다 모두 url을 마스킹하고 query를 전송하기 할 수있다.

```js
// /movie/:id?title=potato 로 전송되는 것이 아니라
// /movie/:id 로 전송된다.
const onClick = (id: number) => {
  router.push(
    {
      pathname: `/movies/${id}`,
      query: {
        title: 'potato',
      },
    },
    `/movies/${id}` // url 마스킹
  );
};
```

- <Link> 사용

```js
<Link
  href={{
    pathname: `/movies/${movie.id}`,
    query: {
      title: movie.title,
    },
  }}
  as={`/movies/${movie.id}`}
  key={movie.id}
>
  <a>{movie.title}</a>
</Link>
```

- getServerSideProps() 를 이용하여 query, params 를 뺏어서 SEO를 구현할 수 있다.
- params: 이 페이지에서 dynamic route(동적 경로)를 사용하는 경우 params에 route parameter가 포함. 페이지 이름이 [id].js이면 params는 { id: ... }처럼 보일 것입니다.
- query: 쿼리 문자열을 나타내는 객체입니다.

```js
type MovieDetailParams = [string, string] | [];

export default function Detail({ propsId }) {
  const router = useRouter();
  const qv = propsId || router.query.id;
  const [id, title] = (qv || []) as MovieDetailParams;
  console.log(id, title);

  return (
    <>
      <div>Movie Detail</div>
      <div>id: {id}</div>
      <div>title: {title}</div>
    </>
  );
}

interface CTXParams {
  params: {
    id: MovieDetailParams;
  };
}

export function getServerSideProps({ params: { id } }: CTXParams) {
  return {
    props: {
      id,
    },
  };
}
```

### 404 페이지: pages/404.js 파일을 만들면 끝!
